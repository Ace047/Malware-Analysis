; Demo - putting constant length strings into a buffer and displaying them again
; We will also show buffer overflow with this program
; Joe Norton October 2021
%include "/home/malware/asm/joey_lib_io_v6_release.asm"

global main

section .data
    str_enter_string db "Please enter a string", 10, 0
    str_this_long db "The string is this long: ", 0

section .bss
    string_size equ 10 ; this is the number of bytes of each string (including the NULL)
    number_of_strings equ 50 ; num strings in the array
    buff_size equ string_size * number_of_strings ; amount of memory we need to allocate
	
    buff: resb buff_size ; this is an uninitiaised buffer big enough for number_of_strings strings

section .text

main:
    mov rbp, rsp; for correct debugging
    push rbp    ; this is just
    mov rbp, rsp; setting up the
    sub rsp, 32 ; stack frame
    
    ;First we are going to enter strings into the buffer until empty string is entered
    mov rbx, buff ; we will use rbx as our pointer into the buffer
  .loop1:
    ;print message
    mov rdi, str_enter_string
    call print_string_new
    ;read a new string from command line
    call read_string_new ; pointer to new string in rax
    ;copy the new string into buffer (buff)
    mov rsi, rax ; address of source string to copy - in rsi
    mov rdi, rbx ; address of destination (buff) to copy - in rdi
    call copy_string ; copy our new string into buff

    ;We don't need the length of the string because each one has string_size bytes allocated to it
    movzx rdi, BYTE [rbx] ; move the first byte of the current string into rdi (with zero extend)
    add rbx, string_size ; add the length of string (string_size)
    cmp rdi, 0 ; finish if the string was empty (i.e. the first byte was NULL)
    jne .loop1
    
    ;Next we are going to display the strings
    mov rbx, buff ; we will use rbx as our pointer into the buffer
  .loop2:
    movzx rax, BYTE [rbx] ; move the first byte of the current string into rax (with zero extend)
    cmp rax, 0
    je .finish ; if the string is length zero, we have finished
    mov rdi, rbx ; put the pointer to current string into rdi to print it
    call print_string_new ; note that rdi is still pointing to our current string
    call print_nl_new
    add rbx, string_size ; move the pointer to the beginning of the next string
    jmp .loop2
    
  .finish:

    add rsp, 32 ; undoing the
    pop rbp     ; stack frame
    
    ret