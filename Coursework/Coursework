; Coursework assembly program
%include "/home/malware/asm/joey_lib_io_v6_release.asm"
global main
section .data
    menu_str db 10, \
                        "Main Menu", 10, \
                        "1. Add user", 10, \
                        "2. Remove user", 10, \
                        "3. Add computer", 10, \
                        "4. Remove computer", 10, \
                        "5. List all users", 10, \
                        "6. List all computers", 10,\
                        "7. Exit", 10,\
                        "Please enter an option 1-7: ", 10,0
    ;User variables             
    str_forename db "Enter user forename: ", 10, 0
    str_surname db "Enter user surname: ", 10, 0
    str_age db "Enter user age: ", 10, 0
    str_id db "Enter user id: ", 10, 0
    str_email db "Enter user email: ", 10, 0
    str_user_id db "Enter the user id: ", 10, 0
    
    ;User error msg 
    str_bad_id db "Wrong format of id", 10, 0
    str_bad_email db "Wrong format of email", 10,0
    str_bad_user_name db "User with such name not found in the list",10,0
    
    ;PC variables
    str_pc_name db "Enter computer name: ", 10, 0
    str_pc_ip db "Enter computer IP: ", 10, 0
    str_pc_id db "Enter the main user ID: ",10, 0
    str_pc_os db "Enter computer OS: ", 10, 0
    str_pc_dop db "Enter date of purchase; ", 10 ,0
    
    ;Pc error msg
    str_pc_not_found db "Did not find a pc with such name in the list", 10,0
    str_bad_pc_name db "Wrong format of PC name!", 10, 0
    str_bad_pc_ip db "Wrong format of PC IP!", 10, 0
    str_bad_pc_id db "Wrong format of main user ID!", 10, 0
    str_bad_pc_os db "Your chosen os is not supported!", 10, 0
    str_bad_pc_dop db "Wrong format of PC date of purchase!", 10, 0

    ;Menu display messages
    str_option_num db "Option selected: ", 0
    str_wrong_option db "No such option, please try again! ", 10, 0
    str_exit db "You have exited the program!", 10, 0
    
    ;User array definition
    user_size equ 257 ;The total information size of an user
    max_users equ 100 ;Maximum users permited to add
    size_users_array equ user_size*max_users;calculates the array length required to store users
    current_users_num dq 0;sets the current users num to 0
    
    ;Computer array definition
    pc_size equ 257;
    max_pc equ 500
    size_pc_array equ pc_size*max_pc;calculates the array length required to store pc's
    current_pc_num dq 0;sets current pc number to 0
    
    
section .bss
    users: resb size_users_array;Array for storing users details
    pcs: resb  size_pc_array    ;Array for storing pc details
    buff: resb 100;Buffer for the user input string
    
   
section .text
format_email:
    push rax
    push rbx
    push rcx
    push rdi
    push rsi
    
    mov rbx, buff;rbx the pointer for the buffer
    .formating_loop:
        call read_string_new;stores input into rax
        mov rsi, rax; source to be copied into buffed
        mov rdi, rbx; destination to copy
        call copy_string; copies the string into the buffer
        mov al, BYTE[buff]
        cmp al, 0; if the string is empty, finish the process
        je .bad_format
        
        mov rax, QWORD[rbx]; moves the 8bit word into rax
        cmp al, '@';checks if the first syumbol is @ and displays error msg
        je .bad_format; jumps to the error msg
        
        .loop1:
            inc rbx; increments rbx to move to next char in the array
            mov rax, QWORD[rbx]; moves array 8bit char into rax
            cmp al ,'@'; compares if the 8 bit char is '@'
            jne .loop1
                        
        
        inc rbx
        mov rax, QWORD[rbx]
        cmp al, 'h'
        jne .bad_format
        inc rbx
        mov rax, QWORD[rbx]
        cmp al, 'e'
        jne .bad_format
        inc rbx
        mov rax, QWORD[rbx]
        cmp al, 'l'
        jne .bad_format
        inc rbx
        mov rax, QWORD[rbx]
        cmp al, 'p'
        jne .bad_format
        inc rbx
        mov rax, QWORD[rbx]
        cmp al, 'd'
        jne .bad_format        
        inc rbx
        mov rax, QWORD[rbx]
        cmp al, 'e'
        jne .bad_format
        inc rbx
        mov rax, QWORD[rbx]
        cmp al, 's'
        jne .bad_format
        inc rbx
        mov rax, QWORD[rbx]
        cmp al, 'k'
        jne .bad_format
        inc rbx
        mov rax, QWORD[rbx]
        cmp al, '.'
        jne .bad_format
        inc rbx
        mov rax, QWORD[rbx]
        cmp al, 'c'
        jne .bad_format
        inc rbx
        mov rax, QWORD[rbx]
        cmp al, 'o'
        jne .bad_format
        inc rbx
        mov rax, QWORD[rbx]
        cmp al, '.'
        jne .bad_format
        inc rbx
        mov rax, QWORD[rbx]
        cmp al, 'u'
        jne .bad_format
        inc rbx
        mov rax, QWORD[rbx]
        cmp al, 'k'
        jne .bad_format
        inc rbx
        mov rax, QWORD[rbx]
        cmp al, 0
        jne .bad_format
        
        pop rax
        pop rbx
        pop rcx
        pop rdi
        pop rsi
        ret
                   
        
        .bad_format:
            mov rdi, str_bad_email
            call print_string_new
            call print_nl_new
            pop rax
            pop rbx
            pop rcx
            pop rdi
            pop rsi
            mov rsi, 1
            ret
        
        
        
        



format_ID:;function for checking the correct suer ID format eg. p19017254
    push rax
    push rbx
    push rcx
    push rdi
    push rsi
    
    mov rbx, buff; rbx used as pointer for the buffer
    .formating_loop:
        call read_string_new ;Stores input to rax
        mov rsi, rax; address of source to copy
        mov rdi, rbx; address of destionation to copy 
        call copy_string ;copies the string into the buffer
        mov al, BYTE[buff]; moves the first byte of the buff into the al
        cmp al,0; if the string is empty, finishes the process
        je .bad_id
        
        mov rax, QWORD[rbx]; moves the 8bit word into rax
        cmp al,'p';comparison for the first character of the id
        jne .bad_id
        
        mov rcx, 7;set the loop count
        shr rax,8 ;moves onto the next 8 bit of the buffer
        .num_loop: ;loops through the string
            
            cmp al, '0'
            jl .bad_id
            cmp al, '9'
            jg .bad_id
            shr rax,8; moves 8 bits on the right
            dec rcx; decrements the loop count
            cmp rcx,0;checks the counter 
            jne .num_loop;if is not 0 then loop again
            cmp al,0;check for null terminator
            jne .bad_id
            pop rax
            pop rbx
            pop rcx
            pop rdi
            pop rsi
            ret
            
            .bad_id:
                mov rdi, str_bad_id
                call print_string_new
                call print_nl_new
                
                pop rax
                pop rbx
                pop rcx
                pop rdi
                pop rsi
                mov rsi,1;moves 1 into rsi for deciding wether to add the string into the array or not
                ret

    
add_user:;Function to add user to the user array
    push rbx
    push rcx
    push rdx
    push rdi
    push rsi
    
    mov rcx, users;setting the base address for the users array
    mov rax, QWORD[current_users_num] ; moving the current users number to rax
    mov rbx, user_size; moving 257 to rbx
    mul rbx ; Multiplies the current users number with the user size and calculates the offset of the next unused address
    add rcx, rax; adds the number of existing users to the users array to check what address is free next
    
    ;get forename
    mov rdi, str_forename ;moves the forename into rdi for printing out
    call print_string_new ;Prints the forename string
    call print_nl_new;prints new line
    call read_string_new;reads input and stores in rax
    mov rsi, rax;adds the address of the string to rsi
    mov rdi, rcx; add the memory address to the rdi
    call copy_string;copies the string from input to the user array
    
    ;get surname
    add rcx, 64 ;adds 64 to the rcx reserved by the forename string
    mov rdi, str_surname ;moves surname into rdi for printing
    call print_string_new; prints what inside rdi
    call print_nl_new;prints new line
    call read_string_new; reads input and stores into rax
    mov rsi, rax;Moves the user input into rsi
    mov rdi, rcx;Moves the reserved address for the surname into rdi for calling copy_string function
    call copy_string ;Copies the RSI content into the RDI address specified
    
    ;get age
    add rcx, 64; Moves 64 bits forward which is reserved for the surname193
    mov rdi, str_age;moves the age into rdi
    call print_string_new;prints the rdi contents
    call print_nl_new;prints new line
    call read_uint_new;takes input and stores into rax
    mov BYTE[rcx], al;copies only the last byte of rax[al] into rcx
    
    ;get id
    inc rcx ;increment by one because the age contains 1 byte only
    mov rdi, str_id; moves the message in rdi for printing out
    call print_string_new;prints out the message
    call print_nl_new;prints a new line
    call format_ID; calls the formating function
    cmp rsi,1;compares rsi to 1
    je .dont_add_id;compares if rsi is 1 then the id format is bad and is not going to be copied into the array
    ;adds the id into the array
    
    mov rsi, buff;moves the buffer which has the id string into the rsi, the source to be copied into the array
    mov rdi, rcx; points to the array address, destiantion for copying the array  
    call copy_string; copies from rsi into rdi
    .dont_add_id:;jumps here for not adding the id to the array
        
    
    ;get email
    add rcx, 64; Moves 64bits forward reserved for the email
    mov rdi, str_email; Moves the message for email input into rdi
    call print_string_new;Prints out the email message string
    call print_nl_new; Prints out a new line
    call format_email
    cmp rsi,1
    je .dont_add_email
    mov rsi, buff
    mov rdi, rcx
    call copy_string
    .dont_add_email:
    
    
    inc QWORD[current_users_num];increases the existing number of users by 1
    pop rbx
    pop rcx
    pop rdx
    pop rdi
    pop rsi
    ret
 
display_users:
    push rbx
    push rcx
    push rdx
    push rdi
    push rsi
    
    lea rsi, [users] ;points to the array with users
    mov rcx, [current_users_num]; rcx used as a counter
    
    .start_loop:
    ;prints forename
    cmp rcx, 0;checks if the counter is 0
    je .end_loop
    mov rdi, rsi; put the pointer of the start of the users array to pass to the print out function
    call print_string_new
    call print_nl_new
    ;prints surname
    lea rdi, [rsi+64] ;moves 64 bit onto the array to print out the next 64 bytes whish is the surname
    call print_string_new
    call print_nl_new
    ;print age
    movzx rdi, BYTE[rsi+128]; extends the 8bytes reserved for the number with zeroes because the age in memory is 1byte and the rdi is 8bytes
    call print_uint_new
    call print_nl_new
    ;print user id
    lea rdi, [rsi+129];
    call print_string_new
    call print_nl_new
    ;print email
    lea rdi, [rsi+193]
    call print_string_new
    call print_nl_new
    call print_nl_new
    
    add rsi, user_size
    dec rcx; decrements rcx because it is one less user to be displayed
        
    jmp .start_loop    
   .end_loop:
    pop rsi
    pop rdi
    pop rdx
    pop rbx
    pop rcx
    ret
    
format_pc_name:
    push rax
    push rbx
    push rcx
    push rdi
    push rsi
    
    mov rbx, buff
    .formating_pc_loop:
        call read_string_new
        mov rsi, rax
        mov rdi, rbx
        call copy_string
        mov al, BYTE[buff]
        cmp al, 0
        je .bad_name
        
        mov rax, QWORD[rbx]
        cmp al, 'c'
        jne .bad_name
        
        mov rcx, 7
        shr rax, 8
        .buff_loop:
            cmp al, '0'
            jl .bad_name
            cmp al, '9'
            jg .bad_name
            shr rax, 8
            dec rcx
            cmp rcx, 0
            jne .buff_loop
            cmp al, 0
            jne .bad_name
            pop rax
            pop rbx
            pop rcx
            pop rdi
            pop rsi
            ret
            
        .bad_name:
            mov rdi, str_bad_pc_name
            call print_string_new
            call print_nl_new
            pop rax
            pop rbx
            pop rcx
            pop rdi
            pop rsi
            mov rsi, 1
            ret
format_pc_ip:
    push rax
    push rbx
    push rcx
    push rdi
    push rsi
    
    mov rbx, buff
    .formating_loop:
        call read_string_new
        mov rsi, rax
        mov rdi, rbx
        call copy_string
        mov rcx,15
        .loop1:
            mov rax, QWORD[rbx]
            inc rbx
            dec rcx
            cmp al,'.'
            je .loop1
            cmp al, 0
            je .end_loop                        
            
            cmp al, '0'
            jl .bad_ip
            cmp al, '9'
            jg .bad_ip
            
            
            
            
            cmp rcx,0
            
            jne .loop1
            .end_loop:
            pop rax
            pop rbx
            pop rcx
            pop rdi
            pop rsi
            ret
            .bad_ip:
                mov rdi, str_bad_pc_ip
                call print_string_new
                call print_nl_new
                pop rax
                pop rbx
                pop rcx
                pop rdi
                pop rsi
                mov rsi,1
                ret
                
format_pc_os:
    push rax
    push rbx
    push rcx
    push rdi
    push rsi
    
    mov rbx, buff
    formating_start:
        call read_string_new
        mov rsi, rax
        mov rdi, rbx
        call copy_string
        
        mov rax, QWORD[rbx]
        cmp al, 'l'
        je .linux_check
        cmp al, 'L'
        je .linux_check
        
        cmp al, 'w'
        je .windows_check
        cmp al, 'W'
        je .windows_check
        
        cmp al, 'm'
        je .mac_check
        cmp al, 'M'
        je .mac_check
        .linux_check:
            inc rbx
            mov rax, QWORD[rbx]
            cmp al, 'i'
            jne .bad_os
            inc rbx
            mov rax, QWORD[rbx]
            cmp al, 'n'
            jne .bad_os
            inc rbx
            mov rax, QWORD[rbx]
            cmp al, 'u'
            inc rbx
            mov rax, QWORD[rbx]
            cmp al, 'x'
            inc rbx
            mov rax, QWORD[rbx]
            cmp al,0
            je .end_loop
            jne .bad_os
        
        .windows_check:
            inc rbx
            mov rax, QWORD[rbx]
            cmp al, 'i'
            inc rbx
            mov rax, QWORD[rbx]
            cmp al, 'n'
            inc rbx
            mov rax, QWORD[rbx]
            cmp al, 'd'
            inc rbx
            mov rax, QWORD[rbx]
            cmp al, 'o'
            inc rbx
            mov rax, QWORD[rbx]
            cmp al, 'w'
            inc rbx
            mov rax, QWORD[rbx]
            cmp al, 's'
            inc rbx
            mov rax, QWORD[rbx]
            cmp al, 0
            je .end_loop
            jne .bad_os
            
        .mac_check:
            inc rbx
            mov rax, QWORD[rbx]
            cmp al, 'a'
            inc rbx
            mov rax, QWORD[rbx]
            cmp al, 'c'
            inc rbx
            mov rax, QWORD[rbx]
            cmp al, ' '
            inc rbx
            mov rax, QWORD[rbx]
            cmp al, 'o'
            inc rbx
            mov rax, QWORD[rbx]
            cmp al, 's'
            inc rbx
            mov rax, QWORD[rbx]
            cmp al, 'x'
            inc rbx
            mov rax, QWORD[rbx]
            cmp al, 0
            jne .bad_os
            
        .end_loop:
            pop rax
            pop rbx
            pop rcx
            pop rdi
            pop rsi
            ret        
        
        
        .bad_os:
            mov rdi, str_bad_pc_os
            call print_string_new
            call print_nl_new
            pop rax
            pop rbx
            pop rcx
            pop rdi
            pop rsi
            mov rsi,1
            ret
        
format_pc_id:;function for checking the correct suer ID format eg. p19017254
    push rax
    push rbx
    push rcx
    push rdi
    push rsi
    
    mov rbx, buff; rbx used as pointer for the buffer
    .formating_start:
        call read_string_new ;Stores input to rax
        mov rsi, rax; address of source to copy
        mov rdi, rbx; address of destionation to copy 
        call copy_string ;copies the string into the buffer
        mov al, BYTE[buff]; moves the first byte of the buff into the al
        cmp al,0; if the string is empty, finishes the process
        je .bad_id
        
        mov rax, QWORD[rbx]; moves the 8bit word into rax
        cmp al,'p';comparison for the first character of the id
        jne .bad_id
        
        mov rcx, 7;set the loop count
        shr rax,8 ;moves onto the next 8 bit of the buffer
        .num_loop: ;loops through the string
            
            cmp al, '0'
            jl .bad_id
            cmp al, '9'
            jg .bad_id
            shr rax,8; moves 8 bits on the right
            dec rcx; decrements the loop count
            cmp rcx,0;checks the counter 
            jne .num_loop;if is not 0 then loop again
            cmp al,0;check for null terminator
            jne .bad_id
            pop rax
            pop rbx
            pop rcx
            pop rdi
            pop rsi
            ret
            
            .bad_id:
                mov rdi, str_bad_id
                call print_string_new
                call print_nl_new
                
                pop rax
                pop rbx
                pop rcx
                pop rdi
                pop rsi
                mov rsi,1;moves 1 into rsi for deciding wether to add the string into the array or not
                ret                        
            
format_pc_dop:
    push rax
    push rbx
    push rcx
    push rdi
    push rsi
    
            mov rbx, buff
            .formating_start:
                call read_string_new
                mov rsi, rax
                mov rdi, rbx
                call copy_string
                mov al, BYTE[buff]
                cmp al,0
                je .bad_dop
                mov rax, QWORD[rbx]
                cmp al, '/'
                je .bad_dop
                mov rcx, 10
                .loop:
                mov rax, QWORD[rbx]
                inc rbx
                dec rcx
                cmp al, '/'
                je .loop
                cmp al, '0'
                jl .bad_dop
                cmp al, '9'
                jg .bad_dop
                cmp rax, 0
                je .end_loop
                cmp rcx, 0
                jne .loop
                .end_loop:
                    pop rax
                    pop rbx
                    pop rcx
                    pop rdi
                    pop rsi
                    ret
                
                .bad_dop:
                    mov rdi, str_bad_pc_dop
                    call print_string_new
                    call print_nl_new
                    pop rax
                    pop rbx
                    pop rcx
                    pop rdi
                    pop rsi
                    mov rsi, 1
                    ret
                        
                        
    
add_pc:
    push rbx
    push rcx
    push rdx
    push rdi
    push rsi
    
    mov rcx, pcs;sets the base address for the pc array
    mov rax, QWORD[current_pc_num];moves the current users num to rax
    mov rbx, pc_size;rbx used for the pc size
    mul rbx;multiplies the pc_size with the current_pc_num  to calculate the offset of the next unused address
    add rcx, rax;adds the number of existing pcs with the pc array to get the address of the next free address
    
    ;get pc name
    mov rdi, str_pc_name
    call print_string_new
    call print_nl_new
    call format_pc_name
    cmp rsi,1
    je .dont_add_name
    mov rsi, buff;source 
    mov rdi, rcx;destination
    call copy_string
    .dont_add_name:

    
;    get pc ip address
    add rcx, 64
    mov rdi, str_pc_ip
    call print_string_new
    call print_nl_new   
    call format_pc_ip
    cmp rsi,1
    je .dont_add_ip
    mov rsi, buff
    mov rdi, rcx
    call copy_string
    .dont_add_ip:
     
    ;get pc os
    add rcx, 64
    mov rdi, str_pc_os
    call print_string_new
    call print_nl_new
    call format_pc_os
    cmp rsi, 1
    je .dont_add_os
    mov rsi, buff
    mov rdi, rcx
    call copy_string
    .dont_add_os:
    
    ;get pc user id
    add rcx, 64
    mov rdi, str_pc_id
    call print_string_new
    call print_nl_new
    call format_pc_id
    cmp rsi,1
    je .dont_add_id
    mov rsi, buff
    mov rdi, rcx
    call copy_string
    .dont_add_id:
    
    ;get pc date of purchase format eg. (21/01/2019)
    add rcx, 64
    mov rdi, str_pc_dop
    call print_string_new
    call print_nl_new
    call format_pc_dop
    cmp rsi, 1
    je .dont_add_dop
    mov rsi, buff
    mov rdi, rcx
    call copy_string
    .dont_add_dop:
    
    inc QWORD[current_pc_num];increases the existing number of pcs by 1    
    pop rbx
    pop rcx
    pop rdx
    pop rdi
    pop rsi
    ret
    
    
display_pcs:
    push rbx
    push rcx
    push rdx
    push rsi
    
    lea rsi, [pcs] ;points to the array with pcs
    mov rcx, [current_pc_num]; rcx used as a counter
    
    .start_loop:
    ;prints pc name
    cmp rcx, 0;checks if the counter is 0
    je .end_loop
    mov rdi, rsi; put the pointer of the start of the users array to pass to the print out function
    call print_string_new
    call print_nl_new    
    ;prints pc ip
    lea rdi, [rsi+64]
    call print_string_new
    call print_nl_new
    ;prints pc os
    lea rdi, [rsi+128]
    call print_string_new
    call print_nl_new
    ;print pc user id
    lea rdi, [rsi+192]
    call print_string_new
    call print_nl_new
    ;print pc date of purchase
    lea rdi, [rsi+256]
    call print_string_new
    call print_nl_new
    
    
    add rsi, pc_size
    dec rcx
    call print_nl_new
    jmp .start_loop
    
    .end_loop:
        pop rbx
        pop rcx
        pop rdx
        pop rsi
        ret
                       
remove_user:
    push rax
    push rbx
    push rcx
    push rdx
    push rdi
    push rsi
        mov rbx, buff ;rbx used as pointer to buffer
        mov rdi, str_forename ;moves string into rdi for printing
        call print_string_new;prints out the string
        call read_string_new;stores input into rax, the input is the name of the user that you want to delete
        mov rsi, rax;moves the input into rsi
        mov rdi, rbx;moves the buffer pointer into rdi for copying
        call copy_string;copies from rsi to rdi
        mov rsi, user_size;rsi used as the user size bytes and count how many bytes to delete from the array
        
        mov rcx, users;rcx used as pointer to the users array
        mov rdi, 0;rdi used as counter to check if the name is found in the array
        .find_name:;loop used to check if the buffer characters correspond to the user name in the user array 
            mov rax, QWORD[rbx];moves 8 bytes of the buffer into rax
            mov rdx, QWORD[rcx];moves 8 bytes of the users array into rdx
            cmp al, 0 ;compares if the buffer is empty
            je .decrement_array;if is empty then jump to decrement array section
            
            cmp al, dl;compares the buffer character to the array character
            je .check_next_char; if the character matches jump to check_next char
            jne .check_next_user;if the character doesnt match then jump to check_next_user
            
        .check_next_char:; checks the next character from the buffer and from the array
             inc rcx;increments rcx to go to next byte in the users array
             inc rbx;increments rbx to go to the next byte in the buffer array
             inc rdi;increments the counter
             jmp .find_name;jumps to find_name loop
         .check_next_user:;checks the next available user
            add rcx, user_size;moves to the next available 256 bytes of the users array
            cmp rcx,0 ;compares if the user array reached the null terminator
            je .bad_username;if  null terminator reached finish the function because no such user exists
            jmp .find_name;jumps to find name loop
             
         .decrement_array:;shifts backwards the array bytes to delete from the start of the user section
            dec rcx;decrements the address of the user array
            dec rdi;decrements the counter
            cmp rdi,0;compare if the counter reached 0
            jne .decrement_array;perform loop until counter decrements to 0
         .delete_whole:;deletes the whole user
            mov BYTE[rcx], 0;replaces the byte of the array with 0
            inc rcx;increments rcx to go to the next byte in the users array
            dec rsi; decrements the rsi with the size of the user variable
            cmp rsi,0;compare if it reached 0
            jne .delete_whole;if not equal loop again
 
         .finish:;end of function
            
            pop rax
            pop rbx
            pop rcx
            pop rdx
            pop rdi
            pop rsi
            ret
         .bad_username:
            mov rdi, str_bad_user_name
            call print_string_new
            call print_nl_new
            pop rax
            pop rbx
            pop rcx
            pop rdx
            pop rdi
            pop rsi
            ret
         
remove_pc:
    push rax
    push rbx
    push rcx
    push rdx
    push rdi
    push rsi
        mov rbx, buff ;rbx used as pointer to buffer
        mov rdi, str_pc_name ;moves string into rdi for printing
        call print_string_new;prints out the string
        call read_string_new;stores input into rax, the input is the name of the user that you want to delete
        mov rsi, rax;moves the input into rsi
        mov rdi, rbx;moves the buffer pointer into rdi for copying
        call copy_string;copies from rsi to rdi
        mov rsi, pc_size;rsi used as the user size bytes and count how many bytes to delete from the array
        
        mov rcx, pcs;rcx used as pointer to the users array
        mov rdi, 0;rdi used as counter to check if the name is found in the array
        .find_name:;loop used to check if the buffer characters correspond to the user name in the user array 
            mov rax, QWORD[rbx];moves 8 bytes of the buffer into rax
            mov rdx, QWORD[rcx];moves 8 bytes of the users array into rdx
            cmp al, 0 ;compares if the buffer is empty
            je .decrement_array;if is empty then jump to decrement array section
            
            cmp al, dl;compares the buffer character to the array character
            je .check_next_char; if the character matches jump to check_next char
            jne .check_next_user;if the character doesnt match then jump to check_next_user
            
        .check_next_char:; checks the next character from the buffer and from the array
             inc rcx;increments rcx to go to next byte in the users array
             inc rbx;increments rbx to go to the next byte in the buffer array
             inc rdi;increments the counter
             jmp .find_name;jumps to find_name loop
         .check_next_user:;checks the next available user
            add rcx, user_size;moves to the next available 256 bytes of the users array
            cmp rcx,0 ;compares if the user array reached the null terminator
            je .finish;if  null terminator reached finish the function
            jmp .find_name;jumps to find name loop
             
         .decrement_array:;shifts backwards the array bytes to delete from the start of the user section
            dec rcx;decrements the address of the user array
            dec rdi;decrements the counter
            cmp rdi,0;compare if the counter reached 0
            jne .decrement_array;perform loop until counter decrements to 0
         .delete_whole:;deletes the whole user
            mov BYTE[rcx], 0;replaces the byte of the array with 0
            inc rcx;increments rcx to go to the next byte in the users array
            dec rsi; decrements the rsi with the size of the user variable
            cmp rsi,0;compare if it reached 0
            jne .delete_whole;if not equal loop again
 
         .finish:;end of function
            
            pop rax
            pop rbx
            pop rcx
            pop rdx
            pop rdi
            pop rsi
            ret   
            
        .bad_username:;if computer name not found jump here
            mov rdi, str_pc_not_found ;displays message of copmuter name not found
            call print_string_new;prints the message
            call print_nl_new;prints new line
            pop rax
            pop rbx
            pop rcx
            pop rdx
            pop rdi
            pop rsi
            ret
            
    
    


        
                        
display_menu:
    push rdi
    mov rdi, menu_str
    call print_string_new
    pop rdi
    ret
                                                
main:
    mov rbp, rsp; for correct debugging
    ; We have these three lines for compatability only
    push rbp
    mov rbp, rsp
    sub rsp,32
    

    
    .menu_loop:
        call display_menu
        call read_int_new
        mov rdx, rax
        cmp rdx, 0
        je .option_7
        cmp rdx,1
        je .option_1
        cmp rdx, 2
        je .option_2
        cmp rdx,3
        je .option_3
        cmp rdx, 4
        je .option_4
        cmp rdx,5
        je .option_5
        cmp rdx, 6
        je .option_6
        cmp rdx, 7; Compares RDX to 7
        je .option_7 ;Exits if it is equal 7

        mov rdi, str_wrong_option
        call print_string_new
        jmp .menu_loop
        
    .option_1:
        call add_user
        jmp .menu_loop
    .option_2:
        call remove_user
        jmp .menu_loop
    .option_3:
        call add_pc
        jmp .menu_loop
    .option_4:
        call remove_pc
        jmp .menu_loop           
    .option_5:
        call display_users
        jmp .menu_loop
    .option_6:
        call display_pcs
        jmp .menu_loop    
    .option_7:
        call exit
            
        
exit:
    
    xor rax,rax ;return 0
    ;compatibility lines
    add rsp, 32
    pop rbp
    ;end of lines
    ret