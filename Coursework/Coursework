; Coursework assembly program
%include "/home/malware/asm/joey_lib_io_v6_release.asm"
global main
section .data
    menu_str db 10, \
                        "Main Menu", 10, \
                        "1. Add user", 10, \
                        "2. Remove user", 10, \
                        "3. Add computer", 10, \
                        "4. Remove computer", 10, \
                        "5. List all users", 10, \
                        "6. List all computers", 10,\
                        "7. Exit", 10,\
                        "Please enter an option 1-7: ", 10,0
    ;User variables             
    str_forename db "Enter user forename: ", 10, 0
    str_surname db "Enter user surname: ", 10, 0
    str_age db "Enter user age: ", 10, 0
    str_id db "Enter user id: ", 10, 0
    str_email db "Enter user email: ", 10, 0
    str_user_id db "Enter the user id: ", 10, 0
    
    ;User error msg 
    str_bad_id db "Wrong format of id", 10, 0
    str_bad_email db "Wrong format of email", 10,0
    
    ;PC variables
    str_pc_name db "Enter computer name: ", 10, 0
    str_pc_ip db "Enter computer IP: ", 10, 0
    str_pc_id db "Enter the main user ID: ",10, 0
    str_pc_os db "Enter computer OS: ", 10, 0
    str_pc_dop db "Enter date of purchase; ", 10 ,0
    
    ;Pc error msg
    str_bad_pc_name db "Wrong format of PC name!", 10, 0
    str_bad_pc_ip db "Wrong format of PC IP!", 10, 0
    str_bad_pc_id db "Wrong format of main user ID!", 10, 0
    str_bad_pc_os db "Your chosen os is not supported!", 10, 0
    str_bad_pc_dop db "Wrong format of PC date of purchase!", 10, 0

    ;Menu display messages
    str_option_num db "Option selected: ", 0
    str_wrong_option db "No such option, please try again! ", 10, 0
    str_exit db "You have exited the program!", 10, 0
    
    ;User array definition
    user_size equ 257 ;The total information size of an user
    max_users equ 100 ;Maximum users permited to add
    size_users_array equ user_size*max_users;calculates the array length required to store users
    current_users_num dq 0;sets the current users num to 0
    
    ;Computer array definition
    pc_size equ 257;
    max_pc equ 100
    size_pc_array equ pc_size*max_pc;calculates the array length required to store pc's
    current_pc_num dq 0;sets current pc number to 0
    
    
section .bss
    users: resb size_users_array;Array for storing users details
    pcs: resb  size_pc_array    ;Array for storing pc details
    buff: resb 100;Buffer for the user input string
    
   
section .text
format_email:
    push rax
    push rbx
    push rcx
    push rdi
    push rsi
    
    mov rbx, buff;rbx the pointer for the buffer
    .formating_loop:
        call read_string_new;stores input into rax
        mov rsi, rax; source to be copied into buffed
        mov rdi, rbx; destination to copy
        call copy_string; copies the string into the buffer
        mov al, BYTE[buff]
        cmp al, 0; if the string is empty, finish the process
        je .bad_format
        
        mov rax, QWORD[rbx]; moves the 8bit word into rax
        cmp al, '@';checks if the first syumbol is @ and displays error msg
        je .bad_format; jumps to the error msg
        
        .loop1:
            inc rbx; increments rbx to move to next char in the array
            mov rax, QWORD[rbx]; moves array 8bit char into rax
            cmp al ,'@'; compares if the 8 bit char is '@'
            jne .loop1
                        
        
        inc rbx
        mov rax, QWORD[rbx]
        cmp al, 'h'
        jne .bad_format
        inc rbx
        mov rax, QWORD[rbx]
        cmp al, 'e'
        jne .bad_format
        inc rbx
        mov rax, QWORD[rbx]
        cmp al, 'l'
        jne .bad_format
        inc rbx
        mov rax, QWORD[rbx]
        cmp al, 'p'
        jne .bad_format
        inc rbx
        mov rax, QWORD[rbx]
        cmp al, 'd'
        jne .bad_format        
        inc rbx
        mov rax, QWORD[rbx]
        cmp al, 'e'
        jne .bad_format
        inc rbx
        mov rax, QWORD[rbx]
        cmp al, 's'
        jne .bad_format
        inc rbx
        mov rax, QWORD[rbx]
        cmp al, 'k'
        jne .bad_format
        inc rbx
        mov rax, QWORD[rbx]
        cmp al, '.'
        jne .bad_format
        inc rbx
        mov rax, QWORD[rbx]
        cmp al, 'c'
        jne .bad_format
        inc rbx
        mov rax, QWORD[rbx]
        cmp al, 'o'
        jne .bad_format
        inc rbx
        mov rax, QWORD[rbx]
        cmp al, '.'
        jne .bad_format
        inc rbx
        mov rax, QWORD[rbx]
        cmp al, 'u'
        jne .bad_format
        inc rbx
        mov rax, QWORD[rbx]
        cmp al, 'k'
        jne .bad_format
        inc rbx
        mov rax, QWORD[rbx]
        cmp al, 0
        jne .bad_format
        
        pop rax
        pop rbx
        pop rcx
        pop rdi
        pop rsi
        ret
                   
        
        .bad_format:
            mov rdi, str_bad_email
            call print_string_new
            call print_nl_new
            pop rax
            pop rbx
            pop rcx
            pop rdi
            pop rsi
            mov rsi, 1
            ret
        
        
        
        



format_ID:;function for checking the correct suer ID format eg. p19017254
    push rax
    push rbx
    push rcx
    push rdi
    push rsi
    
    mov rbx, buff; rbx used as pointer for the buffer
    .formating_loop:
        call read_string_new ;Stores input to rax
        mov rsi, rax; address of source to copy
        mov rdi, rbx; address of destionation to copy 
        call copy_string ;copies the string into the buffer
        mov al, BYTE[buff]; moves the first byte of the buff into the al
        cmp al,0; if the string is empty, finishes the process
        je .bad_id
        
        mov rax, QWORD[rbx]; moves the 8bit word into rax
        cmp al,'p';comparison for the first character of the id
        jne .bad_id
        
        mov rcx, 7;set the loop count
        shr rax,8 ;moves onto the next 8 bit of the buffer
        .num_loop: ;loops through the string
            
            cmp al, '0'
            jl .bad_id
            cmp al, '9'
            jg .bad_id
            shr rax,8; moves 8 bits on the right
            dec rcx; decrements the loop count
            cmp rcx,0;checks the counter 
            jne .num_loop;if is not 0 then loop again
            cmp al,0;check for null terminator
            jne .bad_id
            pop rax
            pop rbx
            pop rcx
            pop rdi
            pop rsi
            ret
            
            .bad_id:
                mov rdi, str_bad_id
                call print_string_new
                call print_nl_new
                
                pop rax
                pop rbx
                pop rcx
                pop rdi
                pop rsi
                mov rsi,1;moves 1 into rsi for deciding wether to add the string into the array or not
                ret

    
add_user:;Function to add user to the user array
    push rbx
    push rcx
    push rdx
    push rdi
    push rsi
    
    mov rcx, users;setting the base address for the users array
    mov rax, QWORD[current_users_num] ; moving the current users number to rax
    mov rbx, user_size; moving 257 to rbx
    mul rbx ; Multiplies the current users number with the user size and calculates the offset of the next unused address
    add rcx, rax; adds the number of existing users to the users array to check what address is free next
    
    ;get forename
    mov rdi, str_forename ;moves the forename into rdi for printing out
    call print_string_new ;Prints the forename string
    call print_nl_new;prints new line
    call read_string_new;reads input and stores in rax
    mov rsi, rax;adds the address of the string to rsi
    mov rdi, rcx; add the memory address to the rdi
    call copy_string;copies the string from input to the user array
    
    ;get surname
    add rcx, 64 ;adds 64 to the rcx reserved by the forename string
    mov rdi, str_surname ;moves surname into rdi for printing
    call print_string_new; prints what inside rdi
    call print_nl_new;prints new line
    call read_string_new; reads input and stores into rax
    mov rsi, rax;Moves the user input into rsi
    mov rdi, rcx;Moves the reserved address for the surname into rdi for calling copy_string function
    call copy_string ;Copies the RSI content into the RDI address specified
    
    ;get age
    add rcx, 64; Moves 64 bits forward which is reserved for the surname193
    mov rdi, str_age;moves the age into rdi
    call print_string_new;prints the rdi contents
    call print_nl_new;prints new line
    call read_uint_new;takes input and stores into rax
    mov BYTE[rcx], al;copies only the last byte of rax[al] into rcx
    
    ;get id
    inc rcx ;increment by one because the age contains 1 byte only
    mov rdi, str_id; moves the message in rdi for printing out
    call print_string_new;prints out the message
    call print_nl_new;prints a new line
    call format_ID; calls the formating function
    cmp rsi,1;compares rsi to 1
    je .dont_add_id;compares if rsi is 1 then the id format is bad and is not going to be copied into the array
    ;adds the id into the array
    
    mov rsi, buff;moves the buffer which has the id string into the rsi, the source to be copied into the array
    mov rdi, rcx; points to the array address, destiantion for copying the array  
    call copy_string; copies from rsi into rdi
    .dont_add_id:;jumps here for not adding the id to the array
        
    
    ;get email
    add rcx, 64; Moves 64bits forward reserved for the email
    mov rdi, str_email; Moves the message for email input into rdi
    call print_string_new;Prints out the email message string
    call print_nl_new; Prints out a new line
    call format_email
    cmp rsi,1
    je .dont_add_email
    mov rsi, buff
    mov rdi, rcx
    call copy_string
    .dont_add_email:
    
    
    inc QWORD[current_users_num];increases the existing number of users by 1
    pop rbx
    pop rcx
    pop rdx
    pop rdi
    pop rsi
    ret
 
display_users:
    push rbx
    push rcx
    push rdx
    push rdi
    push rsi
    
    lea rsi, [users] ;points to the array with users
    mov rcx, [current_users_num]; rcx used as a counter
    
    .start_loop:
    ;prints forename
    cmp rcx, 0;checks if the counter is 0
    je .end_loop
    mov rdi, rsi; put the pointer of the start of the users array to pass to the print out function
    call print_string_new
    call print_nl_new
    ;prints surname
    lea rdi, [rsi+64] ;moves 64 bit onto the array to print out the next 64 bytes whish is the surname
    call print_string_new
    call print_nl_new
    ;print age
    movzx rdi, BYTE[rsi+128]; extends the 8bytes reserved for the number with zeroes because the age in memory is 1byte and the rdi is 8bytes
    call print_uint_new
    call print_nl_new
    ;print user id
    lea rdi, [rsi+129];
    call print_string_new
    call print_nl_new
    ;print email
    lea rdi, [rsi+193]
    call print_string_new
    call print_nl_new
    call print_nl_new
    
    add rsi, user_size
    dec rcx; decrements rcx because it is one less user to be displayed
        
    jmp .start_loop    
   .end_loop:
    pop rsi
    pop rdi
    pop rdx
    pop rbx
    pop rcx
    ret
    
format_pc_name:
    push rax
    push rbx
    push rcx
    push rdi
    push rsi
    
    mov rbx, buff
    .formating_pc_loop:
        call read_string_new
        mov rsi, rax
        mov rdi, rbx
        call copy_string
        mov al, BYTE[buff]
        cmp al, 0
        je .bad_name
        
        mov rax, QWORD[rbx]
        cmp al, 'c'
        jne .bad_name
        
        mov rcx, 7
        shr rax, 8
        .buff_loop:
            cmp al, '0'
            jl .bad_name
            cmp al, '9'
            jg .bad_name
            shr rax, 8
            dec rcx
            cmp rcx, 0
            jne .buff_loop
            cmp al, 0
            jne .bad_name
            pop rax
            pop rbx
            pop rcx
            pop rdi
            pop rsi
            ret
            
        .bad_name:
            mov rdi, str_bad_pc_name
            call print_string_new
            call print_nl_new
            pop rax
            pop rbx
            pop rcx
            pop rdi
            pop rsi
            mov rsi, 1
            ret
format_pc_ip:
    push rax
    push rbx
    push rcx
    push rdi
    push rsi
    
    mov rbx, buff
    .formating_loop:
        call read_string_new
        mov rsi, rax
        mov rdi, rbx
        call copy_string
        mov rcx,15
        .loop1:
            mov rax, QWORD[rbx]
            inc rbx
            dec rcx
            cmp al,'.'
            je .loop1
            cmp al, 0
            je .end_loop                        
            
            cmp al, '0'
            jl .bad_ip
            cmp al, '9'
            jg .bad_ip
            
            
            
            
            cmp rcx,0
            
            jne .loop1
            .end_loop:
            pop rax
            pop rbx
            pop rcx
            pop rdi
            pop rsi
            ret
            .bad_ip:
                mov rdi, str_bad_pc_ip
                call print_string_new
                call print_nl_new
                pop rax
                pop rbx
                pop rcx
                pop rdi
                pop rsi
                mov rsi,1
                ret
                
            
            
        
                        
    
add_pc:
    push rbx
    push rcx
    push rdx
    push rdi
    push rsi
    
    mov rcx, pcs;sets the base address for the pc array
    mov rax, QWORD[current_pc_num];moves the current users num to rax
    mov rbx, pc_size;rbx used for the pc size
    mul rbx;multiplies the pc_size with the current_pc_num  to calculate the offset of the next unused address
    add rcx, rax;adds the number of existing pcs with the pc array to get the address of the next free address
    
    ;get pc name
    mov rdi, str_pc_name
    call print_string_new
    call print_nl_new
    call format_pc_name
    cmp rsi,1
    je .dont_add_name
    mov rsi, buff;source 
    mov rdi, rcx;destination
    call copy_string
    .dont_add_name:

    
;    get pc ip address
    add rcx, 64
    mov rdi, str_pc_ip
    call print_string_new
    call print_nl_new   
    call format_pc_ip
    cmp rsi,1
    je .dont_add_ip
    mov rsi, buff
    mov rdi, rcx
    call copy_string
     .dont_add_ip:

    inc QWORD[current_pc_num];increases the existing number of users by 1    
    pop rbx
    pop rcx
    pop rdx
    pop rdi
    pop rsi
    ret
    
    
display_pcs:
    push rbx
    push rcx
    push rdx
    push rsi
    
    lea rsi, [pcs] ;points to the array with pcs
    mov rcx, [current_pc_num]; rcx used as a counter
    
    .start_loop:
    ;prints pc name
    cmp rcx, 0;checks if the counter is 0
    je .end_loop
    mov rdi, rsi; put the pointer of the start of the users array to pass to the print out function
    call print_string_new
    call print_nl_new    
    ;prints pc ip
    lea rdi, [rsi+64]
    call print_string_new
    call print_nl_new
    
    add rsi, pc_size
    dec rcx
    call print_nl_new
    jmp .start_loop
    
    .end_loop:
        pop rbx
        pop rcx
        pop rdx
        pop rsi
        ret
                       
    
    
    


        
                        
display_menu:
    push rdi
    mov rdi, menu_str
    call print_string_new
    pop rdi
    ret
                                                
main:
    mov rbp, rsp; for correct debugging
    ; We have these three lines for compatability only
    push rbp
    mov rbp, rsp
    sub rsp,32
    

    
    .menu_loop:
        call display_menu
        call read_int_new
        mov rdx, rax
        cmp rdx, 0
        je .option_7
        cmp rdx,1
        je .option_1
        cmp rdx,3
        je .option_3
      
        cmp rdx,5
        je .option_5
        cmp rdx, 6
        je .option_6
        cmp rdx, 7; Compares RDX to 7
        je .option_7 ;Exits if it is equal 7

        mov rdi, str_wrong_option
        call print_string_new
        jmp .menu_loop
        
    .option_1:
        call add_user
        jmp .menu_loop
    .option_3:
        call add_pc
        jmp .menu_loop
        
    
    .option_5:
        call display_users
        jmp .menu_loop
    .option_6:
        call display_pcs
        jmp .menu_loop
    
    .option_7:
        call exit
            
        
exit:
    
    xor rax,rax ;return 0
    ;compatibility lines
    add rsp, 32
    pop rbp
    ;end of lines
    ret