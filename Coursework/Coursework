; Coursework assembly program
%include "/home/malware/asm/joey_lib_io_v6_release.asm"
global main
section .data
    menu_str db 10, \
                        "Main Menu", 10, \
                        "1. Add user", 10, \
                        "2. Remove user", 10, \
                        "3. Add computer", 10, \
                        "4. Remove computer", 10, \
                        "5. List all users", 10, \
                        "6. List all computers", 10,\
                        "7. Exit", 10,\
                        "Please enter an option 1-7: ", 10,0
    ;User variables             
    str_forename db "Enter user forename: ", 10, 0
    str_surname db "Enter user surname: ", 10, 0
    str_dep db "Enter department: ", 10, 0
    str_id db "Enter user id: ", 10, 0
    str_email db "Enter user email: ", 10, 0
    str_user_id db "Enter the user id: ", 10, 0
    
    ;User error msg 
    str_bad_id db "Wrong format of id", 10, 0
    str_bad_email db "Wrong format of email", 10,0
    str_bad_user_name db "User with such name not found in the list",10,0
    str_bad_dep db "Wrong department name!",10,0
    str_bad_name_format db "Wrong format of name",10,0
    str_bad_surname_format db "Wrong format of surname", 10,0
    
    ;PC variables
    str_pc_name db "Enter computer name: ", 10, 0
    str_pc_ip db "Enter computer IP: ", 10, 0
    str_pc_id db "Enter the main user ID: ",10, 0
    str_pc_os db "Enter computer OS: ", 10, 0
    str_pc_dop db "Enter date of purchase; ", 10 ,0
    
    ;Pc error msg
    str_pc_not_found db "Did not find a pc with such name in the list", 10,0
    str_bad_pc_name db "Wrong format of PC name!", 10, 0
    str_bad_pc_ip db "Wrong format of PC IP!", 10, 0
    str_bad_pc_id db "Wrong format of main user ID!", 10, 0
    str_bad_pc_os db "Your chosen os is not supported!", 10, 0
    str_bad_pc_dop db "Wrong format of PC date of purchase!", 10, 0

    ;Menu display messages
    str_option_num db "Option selected: ", 0
    str_wrong_option db "No such option, please try again! ", 10, 0
    str_exit db "You have exited the program!", 10, 0
    
    ;User array definition
    user_size equ 321 ;The total information size of an user
    max_users equ 100 ;Maximum users permited to add
    size_users_array equ user_size*max_users;calculates the array length required to store users
    current_users_num dq 0;sets the current users num to 0
    
    ;Computer array definition
    pc_size equ 321;
    max_pc equ 500
    size_pc_array equ pc_size*max_pc;calculates the array length required to store pc's
    current_pc_num dq 0;sets current pc number to 0
    
    
section .bss
    users: resb size_users_array;Array for storing users details
    pcs: resb  size_pc_array    ;Array for storing pc details
    buff: resb 100;Buffer for the user input string
    
   
section .text
format_name:;formats name allowing only letters and no more than 64 characters
    push rax
    push rbx
    push rcx
    push rdi
    push rsi
    
    
    .formating_loop:
        mov rbx, buff ;rbx as pointer to buffer
        call read_string_new;reads input and stores in rax
        mov rsi, rax ;moves input to rax
        mov rdi, rbx ;moves buffer to rdi
        call copy_string;copies from rsi to rdi
        mov rax, QWORD[rbx];moves the first byte of rbx (buffer) in rax
        cmp al, 0 ;compares if the first char is a null terminator
        je .bad_format;if it is then display error message
        mov rcx, 64;rcx used as counter for the number of letters allowed. 
        
        .check_capital_char:;checks the capital letters
            cmp al, 0;if null terminator detected ends the function
            je .end_loop
            cmp al, 'A';compares the buffer byte to capital A
            jl .bad_format;if the ascii value is lower than capital A displays error msg
            cmp al, 'Z';compares to capital Z
            jg .check_lower_case_char; if the ascii value is greater than capital Z jump to the other loop to check for lower case letter
            inc rbx;increments the next byte in the buffer
            mov rax, QWORD[rbx];move the next byte into rax
            
            dec rcx;decrements the letter number counter
            cmp rcx,0;if it reached 0 it means that the name is bigger than 64 char and will not be added
            je .bad_format;jumps to the bad format loop and will ask for input again
            jmp .check_capital_char;performs this loop again if it reaches this part
        .check_lower_case_char:;checks for lowercase letters
            cmp al, 'a';compares the buff byte to lowercase a
            jl .bad_format;if the ascii value is lower than a, displays error message and will ask for input again
            cmp al, 'z';compares the buff byte to lowercase z
            jg .bad_format;if the char is greater than lowercase z then jump to bad_format loop
            inc rbx;increments next byte in buff
            mov rax, QWORD[rbx];moves the buff byte into rax
            
            dec rcx;decerments letter counter
            cmp rcx,0;compares if letter counter is 0
            je .bad_format;if it equals to 0 then the name is too long and jumps to bad_format loop
            jmp .check_capital_char;if it reaches this section perform the capital letter loop again
            
        .end_loop:;finishes the function
            pop rax;pop all the registries so they return in their initial stat
            pop rbx
            pop rcx
            pop rdi
            pop rsi
            ret
        .bad_format:;displays error message and ask user to enter input again
            mov rdi, str_bad_name_format
            call print_string_new
            call print_nl_new
            mov rdi, str_forename
            call print_string_new
            call print_nl_new
            jmp .formating_loop;jumps to formating_loop and loops again
            
format_surname:;formats surname, works the same way as the format_name function
    push rax
    push rbx
    push rcx
    push rdi
    push rsi
    
    
    .formating_loop:
        mov rbx, buff
        call read_string_new
        mov rsi, rax
        mov rdi, rbx
        call copy_string
        mov rax, QWORD[rbx]
        cmp al, 0
        je .bad_format
        mov rcx, 64
        
        .check_capital_char:
            cmp al, 0
            je .end_loop
            cmp al, 'A'
            jl .bad_format
            cmp al, 'Z'
            jg .check_lower_case_char
            inc rbx
            mov rax, QWORD[rbx]
            
            dec rcx
            cmp rcx, 0
            je .bad_format
            jmp .check_capital_char
        .check_lower_case_char:
            cmp al, 'a'
            jl .bad_format
            cmp al, 'z'
            jg .bad_format
            inc rbx
            mov rax, QWORD[rbx]
            
            dec rcx
            cmp rcx, 0
            je .bad_format
            jmp .check_capital_char
            
        .end_loop:
            pop rax
            pop rbx
            pop rcx
            pop rdi
            pop rsi
            ret
        .bad_format:
            mov rdi, str_bad_surname_format
            call print_string_new
            call print_nl_new
            mov rdi, str_surname
            call print_string_new
            call print_nl_new
            jmp .formating_loop
            
            
format_email:;checks for the format of the email entered by user
    push rax
    push rbx
    push rcx
    push rdi
    push rsi
    
    
    .formating_loop:
        mov rbx, buff;rbx the pointer for the buffer
        call read_string_new;stores input into rax
        mov rsi, rax; source to be copied into buffed
        mov rdi, rbx; destination to copy
        call copy_string; copies the string into the buffer
        mov al, BYTE[buff];moves the first byte of the buff into al
        cmp al, 0; if the string is empty, finish the process
        je .bad_format ;jump to bad format section
        
        mov rax, QWORD[rbx]; moves the 8bit word into rax
        cmp al, '@';checks if the first syumbol is @ and displays error msg
        je .bad_format; jumps to the bad format section
        
        .loop1:
            inc rbx; increments rbx to move to next char in the array
            mov rax, QWORD[rbx]; moves array 8bit char into rax
            cmp al, 0 ;compares if the byte is the null terminator
            je .bad_format;if it is then jump to bad_format section
            cmp al ,'@'; compares if the 8 bit char is '@'
            jne .loop1 ;if the char is not the @ symbol then loop again 
                        
        ;this section checks the other part of the email format (@helpdesk.co.uk)
        inc rbx;goes to next byte in buffer
        mov rax, QWORD[rbx]
        cmp al, 'h'
        jne .bad_format
        inc rbx;goes to next byte in buffer
        mov rax, QWORD[rbx]
        cmp al, 'e'
        jne .bad_format
        inc rbx;goes to next byte in buffer
        mov rax, QWORD[rbx]
        cmp al, 'l'
        jne .bad_format
        inc rbx;goes to next byte in buffer
        mov rax, QWORD[rbx]
        cmp al, 'p'
        jne .bad_format
        inc rbx;goes to next byte in buffer
        mov rax, QWORD[rbx]
        cmp al, 'd'
        jne .bad_format        
        inc rbx;goes to next byte in buffer
        mov rax, QWORD[rbx]
        cmp al, 'e'
        jne .bad_format
        inc rbx;goes to next byte in buffer
        mov rax, QWORD[rbx]
        cmp al, 's'
        jne .bad_format
        inc rbx;goes to next byte in buffer
        mov rax, QWORD[rbx]
        cmp al, 'k'
        jne .bad_format
        inc rbx;goes to next byte in buffer
        mov rax, QWORD[rbx]
        cmp al, '.'
        jne .bad_format
        inc rbx;goes to next byte in buffer
        mov rax, QWORD[rbx]
        cmp al, 'c'
        jne .bad_format
        inc rbx;goes to next byte in buffer
        mov rax, QWORD[rbx]
        cmp al, 'o'
        jne .bad_format
        inc rbx;goes to next byte in buffer
        mov rax, QWORD[rbx]
        cmp al, '.'
        jne .bad_format
        inc rbx;goes to next byte in buffer
        mov rax, QWORD[rbx]
        cmp al, 'u'
        jne .bad_format
        inc rbx;goes to next byte in buffer
        mov rax, QWORD[rbx]
        cmp al, 'k'
        jne .bad_format
        inc rbx;goes to next byte in buffer
        mov rax, QWORD[rbx]
        cmp al, 0
        jne .bad_format
        
        pop rax
        pop rbx
        pop rcx
        pop rdi
        pop rsi
        ret
                   
        
        .bad_format:
            mov rdi, str_bad_email
            call print_string_new
            call print_nl_new
            mov rdi, str_email
            call print_string_new
            call print_nl_new
            jmp .formating_loop
        
        
        
format_dep:; checks for the format of the department
    push rax
    push rbx
    push rcx
    push rdi
    push rsi
    .format_loop:
    mov rbx, buff; rbx used as pointer for the buffer
    call read_string_new;stores input in rax
    mov rsi, rax;moves input in rsi
    mov rdi, rbx;moves buff pointer to rdi
    call copy_string;copies from rsi to rdi
    mov al,BYTE[buff];moves the fist byte of buff into al
    cmp al, 0;compares if null terminator
    je .bad_dep;if it is 0 then diaplsy error msg
    .start_format:
    mov rax, QWORD[rbx]
    cmp al, 'd';if first letter is d jump to development_loop
    je .development_loop
    cmp al, 'D';if first letter capital D jump to development_loop
    je .development_loop
    cmp al, 'i';if first letter is i or I jump to supp_loop
    je .it_supp_loop
    cmp al, 'I'
    je .it_supp_loop
    cmp al,'f';if first letter is f or F jump to finance loop
    je .finance_loop
    cmp al,'F'
    je .finance_loop
    cmp al, 'h'; if first letter is h or H jump to hr_loop
    je .hr_loop
    cmp al, 'H'
    je .hr_loop
    jmp .bad_dep;if the first character is not one of the letters above display error message
    
    .development_loop:;checks for the 'evelopment' string one by one by incrementing the next byte in the buffer
        inc rbx
        mov rax, QWORD[rbx]
        cmp al, 'e'
        jne .bad_dep
        inc rbx
        mov rax, QWORD[rbx]
        cmp al, 'v'
        jne .bad_dep
        inc rbx
        mov rax, QWORD[rbx]
        cmp al, 'e'
        jne .bad_dep
        inc rbx
        mov rax, QWORD[rbx]
        cmp al, 'l'
        jne .bad_dep
        inc rbx
        mov rax, QWORD[rbx]
        cmp al, 'o'
        jne .bad_dep
        inc rbx
        mov rax, QWORD[rbx]
        cmp al, 'p'
        jne .bad_dep
        inc rbx
        mov rax, QWORD[rbx]
        cmp al, 'm'
        jne .bad_dep
        inc rbx
        mov rax, QWORD[rbx]
        cmp al, 'e'
        jne .bad_dep
        inc rbx
        mov rax, QWORD[rbx]
        cmp al, 'n'
        jne .bad_dep
        inc rbx
        mov rax, QWORD[rbx]
        cmp al, 't'
        jne .bad_dep
        inc rbx
        mov rax, QWORD[rbx]
        cmp al, 0
        jne .bad_dep;if null terminator not detected at the end then the format is wrong 
        jmp .finish;if null terminator detected end the function
    
    
    .it_supp_loop:;checks for the 'T Support' string one by one by incrementing the next byte in the buffer
        inc rbx
        mov rax, QWORD[rbx]
        cmp al, 't'
        je .jump1; jump over the capital T character check because letter t was detected
        cmp al, 'T'
        jne .bad_dep
        .jump1:
        inc rbx
        mov rax, QWORD[rbx]
        cmp al, ' '
        jne .bad_dep
        inc rbx
        mov rax, QWORD[rbx]
        cmp al, 's'
        je .jump2
        cmp al, 'S'
        jne .bad_dep
        .jump2:
        
        inc rbx
        mov rax, QWORD[rbx]
        cmp al, 'u'
        jne .bad_dep
        inc rbx
        mov rax, QWORD[rbx]
        cmp al, 'p'
        jne .bad_dep
        inc rbx
        mov rax, QWORD[rbx]
        cmp al, 'p'
        jne .bad_dep
        inc rbx
        mov rax, QWORD[rbx]
        cmp al, 'o'
        jne .bad_dep
        inc rbx
        mov rax, QWORD[rbx]
        cmp al, 'r'
        jne .bad_dep
        inc rbx
        mov rax, QWORD[rbx]
        cmp al, 't'
        jne .bad_dep
        inc rbx
        mov rax, QWORD[rbx]
        cmp al, 0
        jne .bad_dep
        jmp .finish
    .finance_loop:;checks for the 'inance' string one by one by incrementing the next byte in the buffer
        inc rbx
        mov rax, QWORD[rbx]
        cmp al, 'i'
        jne .bad_dep
        inc rbx
        mov rax, QWORD[rbx]
        cmp al, 'n'
        jne .bad_dep
        inc rbx
        mov rax, QWORD[rbx]
        cmp al, 'a'
        jne .bad_dep
        inc rbx
        mov rax, QWORD[rbx]
        cmp al, 'n'
        jne .bad_dep
        inc rbx
        mov rax, QWORD[rbx]
        cmp al, 'c'
        jne .bad_dep
        inc rbx
        mov rax, QWORD[rbx]
        cmp al, 'e'
        jne .bad_dep
        inc rbx
        mov rax, QWORD[rbx]
        cmp al, 0
        jne .bad_dep
        jmp .finish
    .hr_loop:;checks for the 'r' char by incrementing the next byte in the buffer
        inc rbx
        mov rax, QWORD[rbx]
        cmp al, 'r'
        je .finish
        cmp al, 'R'
        jne .bad_dep
        inc rbx
        mov rax, QWORD[rbx]
        cmp al, 0
        jne .bad_dep
        
        
    .finish:;finish of function
        pop rax
        pop rbx
        pop rcx
        pop rdi
        pop rsi
        ret
    
    .bad_dep:;displays error message and jumps to first loop
        mov rdi, str_bad_dep
        call print_string_new
        call print_nl_new
        mov rdi, str_dep
        call print_string_new
        call print_nl_new
        jmp .format_loop

    
    
            



format_ID:;function for checking the correct user ID format eg. p19017254
    push rax
    push rbx
    push rcx
    push rdi
    push rsi
    
    
    .formating_loop:
        mov rbx, buff;move the buffer into rbx
        call read_string_new;store input in rax
        mov rsi, rax;store the input in rsi
        mov rdi, rbx;store the buffer into rdi
        call copy_string;copies from input to buffer
        mov al, BYTE[buff]
        cmp al, 0;checks if the first byte is the null terminator
        je .bad_name
        
        mov rax, QWORD[rbx];checks if the first byte is the letter 'c'
        cmp al, 'p'
        jne .bad_name
        
        mov rcx, 7;loop count, performs 7 times for 7 digit number
        
        .buff_loop:
            inc rbx
            mov rax,QWORD[rbx]
                                    
            cmp al, '0';checks if the id is in range of numbers 0 and 9
            jl .bad_name
            cmp al, '9'
            jg .bad_name
            dec rcx
            cmp rcx,0
            jne .buff_loop
 
            inc rbx
            mov rax, QWORD[rbx]
            cmp al, 0
            jne .bad_name; if the last character is not null terminator display error message
            .finish:
            pop rax
            pop rbx
            pop rcx
            pop rdi
            pop rsi
            ret;end function
            
        .bad_name:;displays error msg and asks for input again
            mov rdi, str_bad_id
            call print_string_new
            call print_nl_new
            mov rdi, str_id
            call print_string_new
            call print_nl_new
            jmp .formating_loop

    
add_user:;Function to add user to the user array
    push rbx
    push rcx
    push rdx
    push rdi
    push rsi
    
    mov rcx, users;setting the base address for the users array
    mov rax, QWORD[current_users_num] ; moving the current users number to rax
    mov rbx, user_size; moving 321 to rbx
    mul rbx ; Multiplies the current users number with the user size and calculates the offset of the next unused address
    add rcx, rax; adds the number of existing users to the users array to check what address is free next
    
    ;get forename
    mov rdi, str_forename ;moves the forename into rdi for printing out
    call print_string_new ;Prints the forename string
    call print_nl_new;prints new line
    call format_name;calls format name function
    mov rsi, buff;adds the address of the buffer to rsi
    mov rdi, rcx; add the user array memory address to the rdi
    call copy_string;copies the string from buffer to the user array
    
    ;get surname
    add rcx, 64 ;adds 64 to the rcx reserved by the forename string
    mov rdi, str_surname ;moves surname into rdi for printing
    call print_string_new; prints what inside rdi
    call print_nl_new;prints new line
    call format_surname ;calls format surname function
    mov rsi, buff;adds the address of the buffer to rsi
    mov rdi, rcx;Moves the reserved address for the surname into rdi for calling copy_string function
    call copy_string ;Copies the RSI content into the RDI address specified
    
    ;get department
    add rcx, 64; Moves 64 bits forward which is reserved for the surname
    mov rdi, str_dep;moves the age into rdi
    call print_string_new;prints the rdi contents
    call print_nl_new;prints new line
    call format_dep;calls format_dep function
    mov rsi, buff ;moves the buffer into rsi
    mov rdi, rcx ;moves the pointer to array into rdi
    call copy_string;copies from buffer to the array
    
    ;get id
    add rcx, 64 ;increment by one because the age contains 1 byte only
    mov rdi, str_id; moves the message in rdi for printing out
    call print_string_new;prints out the message
    call print_nl_new;prints a new line
    call format_ID; calls the formating function
    
    mov rsi, buff;moves the buffer which has the id string into the rsi, the source to be copied into the array
    mov rdi, rcx; points to the array address, destiantion for copying the array  
    call copy_string; copies from rsi into rdi
        
    
    ;get email
    add rcx, 64; Moves 64bits forward reserved for the email
    mov rdi, str_email; Moves the message for email input into rdi
    call print_string_new;Prints out the email message string
    call print_nl_new; Prints out a new line
    call format_email;calls format email function
    mov rsi, buff;
    mov rdi, rcx
    call copy_string;copies from buff to user array
    
    
    inc QWORD[current_users_num];increases the existing number of users by 1
    pop rbx
    pop rcx
    pop rdx
    pop rdi
    pop rsi
    ret
 
display_users:;display users function
    push rbx
    push rcx
    push rdx
    push rdi
    push rsi
    
    lea rsi, [users] ;points to the array with users
    mov rcx, [current_users_num]; rcx used as a counter
    
    .start_loop:
    ;prints forename
    cmp rcx, 0;checks if the counter is 0
    je .end_loop
    mov rdi, rsi; put the pointer of the start of the users array to pass to the print out function
    call print_string_new;
    call print_nl_new
    ;prints surname
    lea rdi, [rsi+64] ;moves 64 bytes onto the array to print out the next 64 bytes whish is the surname
    call print_string_new
    call print_nl_new
    ;print department
    lea rdi, [rsi+128]; moves to next 128 bytes
    call print_string_new
    call print_nl_new
    ;print user id
    lea rdi, [rsi+192];moves to next 192 bytes
    call print_string_new
    call print_nl_new
    ;print email
    lea rdi, [rsi+256];moves to next 256 bytes
    call print_string_new
    call print_nl_new
    call print_nl_new
    
    add rsi, user_size;adds the user size to rsi to point to next user
    dec rcx; decrements rcx because it is one less user to be displayed
        
    jmp .start_loop
   .end_loop:
    pop rsi
    pop rdi
    pop rdx
    pop rbx
    pop rcx
    ret
    
format_pc_name:;chcks the format of pc name
    push rax
    push rbx
    push rcx
    push rdi
    push rsi
    
    
    .formating_loop:
        mov rbx, buff;move the buffer into rbx
        call read_string_new;store input in rax
        mov rsi, rax;store the input in rsi
        mov rdi, rbx;store the buffer into rdi
        call copy_string;copies from input to buffer
        mov al, BYTE[buff]
        cmp al, 0;checks if the first byte is the null terminator
        je .bad_name
        
        mov rax, QWORD[rbx];checks if the first byte is the letter 'c'
        cmp al, 'c'
        jne .bad_name
        
        mov rcx, 7;loop count, performs 7 times for 7 digit number
        
        .buff_loop:
            inc rbx
            mov rax,QWORD[rbx]
                                    
            cmp al, '0';checks if the id is in range of numbers 0 and 9
            jl .bad_name
            cmp al, '9'
            jg .bad_name
            dec rcx
            cmp rcx,0
            jne .buff_loop
 
            inc rbx
            mov rax, QWORD[rbx]
            cmp al, 0
            jne .bad_name; if the last character is not null terminator display error message
            .finish:
            pop rax
            pop rbx
            pop rcx
            pop rdi
            pop rsi
            ret;end function
            
        .bad_name:;displays error msg and asks for input again
            mov rdi, str_bad_pc_name
            call print_string_new
            call print_nl_new
            mov rdi, str_pc_name
            call print_string_new
            call print_nl_new
            jmp .formating_loop

format_pc_ip:;checks format of ip address of pc
    push rax
    push rbx
    push rcx
    push rdi
    push rsi
    
    
    .formating_loop:
        mov rbx, buff;moves buff into rbx
        call read_string_new;moves input in rax
        mov rsi, rax;moves rax to rsi
        mov rdi, rbx;moves buffer into rdi
        call copy_string;copies from input to buffer
        mov al, BYTE[buff]
        cmp al, 0;checks if first byte if null terminator
        je .bad_ip;if it is display eror msg
        mov rcx,15;allows up to 15 numbers for the ip address
        .loop1:
            mov rax, QWORD[rbx]
            inc rbx
            dec rcx
            cmp al,'.';comares if the symbol is '.' and jumps to loop1
            je .loop1
            cmp al, 0
            je .end_loop; if last byte is null terminator end loop                        
            
            cmp al, '0';allows for numbers only
            jl .bad_ip
            cmp al, '9'
            jg .bad_ip;if not number displays error msg
            
            
            
            
            cmp rcx,0;compares the ocunter to 0
            
            jne .loop1;if it didnt reach zero loop again
            .end_loop:;end of function
            pop rax
            pop rbx
            pop rcx
            pop rdi
            pop rsi
            ret
            .bad_ip:;display error message and asks for input again
                mov rdi, str_bad_pc_ip
                call print_string_new
                mov rdi, str_pc_ip
                call print_string_new
                call print_nl_new
                call print_nl_new
                jmp .formating_loop
                
format_pc_os:;checks the format of pc os
    push rax
    push rbx
    push rcx
    push rdi
    push rsi
    
    
    .formating_loop:
        mov rbx, buff;points to buffer array
        call read_string_new;stores input in rax
        mov rsi, rax;moves input into rsi
        mov rdi, rbx;moves the buff into rdi
        call copy_string;copies from input to buff
        mov al, BYTE[buff]
        cmp al, 0;checks if the first byte of buff has the null terminator
        je .bad_os
        
        mov rax, QWORD[rbx]
        ;checks if the first byte contains the character l or L
        cmp al, 'l'
        je .linux_check
        cmp al, 'L'
        je .linux_check
        ;checks if the first byte contains the character w or W
        cmp al, 'w'
        je .windows_check
        cmp al, 'W'
        je .windows_check
        ;checks if the first character contains m or M
        cmp al, 'm'
        je .mac_check
        cmp al, 'M'
        je .mac_check
        .linux_check:;checks if the rest of the characters in the buffer contain 'inux'
            inc rbx
            mov rax, QWORD[rbx]
            cmp al, 'i'
            jne .bad_os
            inc rbx
            mov rax, QWORD[rbx]
            cmp al, 'n'
            jne .bad_os
            inc rbx
            mov rax, QWORD[rbx]
            cmp al, 'u'
            inc rbx
            mov rax, QWORD[rbx]
            cmp al, 'x'
            inc rbx
            mov rax, QWORD[rbx]
            cmp al,0
            je .end_loop
            jne .bad_os
        
        .windows_check:;checks if the rest of the characters in the buffer contain 'indows'
            inc rbx
            mov rax, QWORD[rbx]
            cmp al, 'i'
            inc rbx
            mov rax, QWORD[rbx]
            cmp al, 'n'
            inc rbx
            mov rax, QWORD[rbx]
            cmp al, 'd'
            inc rbx
            mov rax, QWORD[rbx]
            cmp al, 'o'
            inc rbx
            mov rax, QWORD[rbx]
            cmp al, 'w'
            inc rbx
            mov rax, QWORD[rbx]
            cmp al, 's'
            inc rbx
            mov rax, QWORD[rbx]
            cmp al, 0
            je .end_loop
            jne .bad_os
            
        .mac_check:;checks if the rest of the characters in the buffer contain 'ac os'
            inc rbx
            mov rax, QWORD[rbx]
            cmp al, 'a'
            inc rbx
            mov rax, QWORD[rbx]
            cmp al, 'c'
            inc rbx
            mov rax, QWORD[rbx]
            cmp al, ' '
            inc rbx
            mov rax, QWORD[rbx]
            cmp al, 'o'
            inc rbx
            mov rax, QWORD[rbx]
            cmp al, 's'
            inc rbx
            mov rax, QWORD[rbx]
            cmp al, 'x'
            inc rbx
            mov rax, QWORD[rbx]
            cmp al, 0
            jne .bad_os
            
        .end_loop:;finish the function
            pop rax
            pop rbx
            pop rcx
            pop rdi
            pop rsi
            ret        
        
        
        .bad_os:
            mov rdi, str_bad_pc_os
            call print_string_new
            call print_nl_new
            mov rdi, str_pc_os
            call print_string_new
            call print_nl_new
            jmp .formating_loop
        
format_pc_id:;function for checking the correct suer ID format eg. p19017254
    push rax
    push rbx
    push rcx
    push rdi
    push rsi
    
    
    .formating_loop:
        mov rbx, buff;move the buffer into rbx
        call read_string_new;store input in rax
        mov rsi, rax;store the input in rsi
        mov rdi, rbx;store the buffer into rdi
        call copy_string;copies from input to buffer
        mov al, BYTE[buff]
        cmp al, 0;checks if the first byte is the null terminator
        je .bad_name
        
        mov rax, QWORD[rbx];checks if the first byte is the letter 'p'
        cmp al, 'p'
        jne .bad_name
        
        mov rcx, 7;loop count, performs 7 times for 7 digit number
        
        .buff_loop:
            inc rbx
            mov rax,QWORD[rbx]
                                    
            cmp al, '0';checks if the id is in range of numbers 0 and 9
            jl .bad_name
            cmp al, '9'
            jg .bad_name
            dec rcx
            cmp rcx,0
            jne .buff_loop
 
            inc rbx
            mov rax, QWORD[rbx]
            cmp al, 0
            jne .bad_name; if the last character is not null terminator display error message
            .finish:
            pop rax
            pop rbx
            pop rcx
            pop rdi
            pop rsi
            ret;end function
            
        .bad_name:;displays error msg and asks for input again
            mov rdi, str_bad_id
            call print_string_new
            call print_nl_new
            mov rdi, str_id
            call print_string_new
            call print_nl_new
            jmp .formating_loop

                                      
            
format_pc_dop:;checks format of date of purchase for pc
    push rax
    push rbx
    push rcx
    push rdi
    push rsi
    
            
            .formating_loop:
                mov rbx, buff;moves the buff in rbx
                call read_string_new;stores input in rax
                mov rsi, rax;moves the input into rsi
                mov rdi, rbx;moves the buffer into rdi
                call copy_string;copies from rsi to rdi
                mov al, BYTE[buff]
                cmp al,0;checks if the first byte has null terminator
                je .bad_dop
                mov rax, QWORD[rbx]
                cmp al, '/';if the first character is '/' display error msg and ask user for input
                je .bad_dop
                mov rcx, 10;the date is supposed to contain 10 characters eg.(10/12/2020)
                .loop:;this loop allows only numerical input
                mov rax, QWORD[rbx]
                inc rbx
                dec rcx
                cmp al, '/'
                je .loop
                cmp al, '0'
                jl .bad_dop
                cmp al, '9'
                jg .bad_dop
                cmp rax, 0
                je .end_loop
                cmp rcx, 0
                jne .loop
                .end_loop:;finish function
                    pop rax
                    pop rbx
                    pop rcx
                    pop rdi
                    pop rsi
                    ret
                
                .bad_dop:;displays error msg and goes to the main loop
                    mov rdi, str_bad_pc_dop
                    call print_string_new
                    call print_nl_new
                    mov rdi, str_pc_dop
                    call print_string_new
                    call print_nl_new
                    jmp .formating_loop
                        
                        
    
add_pc:
    push rbx
    push rcx
    push rdx
    push rdi
    push rsi
    
    mov rcx, pcs;sets the base address for the pc array
    mov rax, QWORD[current_pc_num];moves the current users num to rax
    mov rbx, pc_size;rbx used for the pc size
    mul rbx;multiplies the pc_size with the current_pc_num  to calculate the offset of the next unused address
    add rcx, rax;adds the number of existing pcs with the pc array to get the address of the next free address
    
    ;get pc name
    mov rdi, str_pc_name
    call print_string_new
    call print_nl_new
    call format_pc_name
    mov rsi, buff;source 
    mov rdi, rcx;destination
    call copy_string

    
;    get pc ip address
    add rcx, 64
    mov rdi, str_pc_ip
    call print_string_new
    call print_nl_new   
    call format_pc_ip

    mov rsi, buff
    mov rdi, rcx
    call copy_string
 
     
    ;get pc os
    add rcx, 64
    mov rdi, str_pc_os
    call print_string_new
    call print_nl_new
    call format_pc_os

    mov rsi, buff
    mov rdi, rcx
    call copy_string
    
    ;get pc user id
    add rcx, 64
    mov rdi, str_pc_id
    call print_string_new
    call print_nl_new
    call format_pc_id

    mov rsi, buff
    mov rdi, rcx
    call copy_string

    
    ;get pc date of purchase format eg. (21/01/2019)
    add rcx, 64
    mov rdi, str_pc_dop
    call print_string_new
    call print_nl_new
    call format_pc_dop

    mov rsi, buff
    mov rdi, rcx
    call copy_string

    
    inc QWORD[current_pc_num];increases the existing number of pcs by 1    
    pop rbx
    pop rcx
    pop rdx
    pop rdi
    pop rsi
    ret
    
    
display_pcs:
    push rbx
    push rcx
    push rdx
    push rsi
    
    lea rsi, [pcs] ;points to the array with pcs
    mov rcx, [current_pc_num]; rcx used as a counter
    
    .start_loop:
    ;prints pc name
    cmp rcx, 0;checks if the counter is 0
    je .end_loop
    mov rdi, rsi; put the pointer of the start of the users array to pass to the print out function
    call print_string_new
    call print_nl_new    
    ;prints pc ip
    lea rdi, [rsi+64]
    call print_string_new
    call print_nl_new
    ;prints pc os
    lea rdi, [rsi+128]
    call print_string_new
    call print_nl_new
    ;print pc user id
    lea rdi, [rsi+192]
    call print_string_new
    call print_nl_new
    ;print pc date of purchase
    lea rdi, [rsi+256]
    call print_string_new
    call print_nl_new
    
    
    add rsi, pc_size
    dec rcx
    call print_nl_new
    jmp .start_loop
    
    .end_loop:
        pop rbx
        pop rcx
        pop rdx
        pop rsi
        ret
                       
remove_user:
    push rax
    push rbx
    push rcx
    push rdx
    push rdi
    push rsi
        mov rbx, buff ;rbx used as pointer to buffer
        mov rdi, str_forename ;moves string into rdi for printing
        call print_string_new;prints out the string
        call read_string_new;stores input into rax, the input is the name of the user that you want to delete
        mov rsi, rax;moves the input into rsi
        mov rdi, rbx;moves the buffer pointer into rdi for copying
        call copy_string;copies from rsi to rdi
        mov rsi, user_size;rsi used as the user size bytes and count how many bytes to delete from the array
        
        mov rcx, users;rcx used as pointer to the users array
        mov rdi, 0;rdi used as counter to check if the name is found in the array
        .find_name:;loop used to check if the buffer characters correspond to the user name in the user array 
            mov rax, QWORD[rbx];moves 8 bytes of the buffer into rax
            mov rdx, QWORD[rcx];moves 8 bytes of the users array into rdx
            cmp al, 0 ;compares if the buffer is empty
            je .decrement_array;if is empty then jump to decrement array section
            
            cmp al, dl;compares the buffer character to the array character
            je .check_next_char; if the character matches jump to check_next char
            jne .check_next_user;if the character doesnt match then jump to check_next_user
            
        .check_next_char:; checks the next character from the buffer and from the array
             inc rcx;increments rcx to go to next byte in the users array
             inc rbx;increments rbx to go to the next byte in the buffer array
             inc rdi;increments the counter
             jmp .find_name;jumps to find_name loop
         .check_next_user:;checks the next available user
            add rcx, user_size;moves to the next available 256 bytes of the users array
            cmp rcx,0 ;compares if the user array reached the null terminator
            je .bad_username;if  null terminator reached finish the function because no such user exists
            jmp .find_name;jumps to find name loop
             
         .decrement_array:;shifts backwards the array bytes to delete from the start of the user section
            dec rcx;decrements the address of the user array
            dec rdi;decrements the counter
            cmp rdi,0;compare if the counter reached 0
            jne .decrement_array;perform loop until counter decrements to 0
         .delete_whole:;deletes the whole user
            mov BYTE[rcx], 0;replaces the byte of the array with 0
            inc rcx;increments rcx to go to the next byte in the users array
            dec rsi; decrements the rsi with the size of the user variable
            cmp rsi,0;compare if it reached 0
            jne .delete_whole;if not equal loop again
 
         .finish:;end of function
            
            pop rax
            pop rbx
            pop rcx
            pop rdx
            pop rdi
            pop rsi
            ret
         .bad_username:
            mov rdi, str_bad_user_name
            call print_string_new
            call print_nl_new
            pop rax
            pop rbx
            pop rcx
            pop rdx
            pop rdi
            pop rsi
            ret
         
remove_pc:
    push rax
    push rbx
    push rcx
    push rdx
    push rdi
    push rsi
        mov rbx, buff ;rbx used as pointer to buffer
        mov rdi, str_pc_name ;moves string into rdi for printing
        call print_string_new;prints out the string
        call read_string_new;stores input into rax, the input is the name of the pc that you want to delete
        mov rsi, rax;moves the input into rsi
        mov rdi, rbx;moves the buffer pointer into rdi for copying
        call copy_string;copies from rsi to rdi
        mov rsi, pc_size;rsi used as the pc size bytes and count how many bytes to delete from the array
        
        mov rcx, pcs;rcx used as pointer to the users array
        mov rdi, 0;rdi used as counter to check if the name is found in the array
        .find_name:;loop used to check if the buffer characters correspond to the user name in the user array 
            mov rax, QWORD[rbx];moves 8 bytes of the buffer into rax
            mov rdx, QWORD[rcx];moves 8 bytes of the users array into rdx
            cmp al, 0 ;compares if the buffer is empty
            je .decrement_array;if is empty then jump to decrement array section
            
            cmp al, dl;compares the buffer character to the array character
            je .check_next_char; if the character matches jump to check_next char
            jne .check_next_user;if the character doesnt match then jump to check_next_user
            
        .check_next_char:; checks the next character from the buffer and from the array
             inc rcx;increments rcx to go to next byte in the users array
             inc rbx;increments rbx to go to the next byte in the buffer array
             inc rdi;increments the counter
             jmp .find_name;jumps to find_name loop
         .check_next_user:;checks the next available user
            add rcx, user_size;moves to the next available 256 bytes of the users array
            cmp rcx,0 ;compares if the user array reached the null terminator
            je .finish;if  null terminator reached finish the function
            jmp .find_name;jumps to find name loop
             
         .decrement_array:;shifts backwards the array bytes to delete from the start of the user section
            dec rcx;decrements the address of the user array
            dec rdi;decrements the counter
            cmp rdi,0;compare if the counter reached 0
            jne .decrement_array;perform loop until counter decrements to 0
         .delete_whole:;deletes the whole user
            mov BYTE[rcx], 0;replaces the byte of the array with 0
            inc rcx;increments rcx to go to the next byte in the users array
            dec rsi; decrements the rsi with the size of the user variable
            cmp rsi,0;compare if it reached 0
            jne .delete_whole;if not equal loop again
 
         .finish:;end of function
            
            pop rax
            pop rbx
            pop rcx
            pop rdx
            pop rdi
            pop rsi
            ret   
            
        .bad_username:;if computer name not found jump here
            mov rdi, str_pc_not_found ;displays message of copmuter name not found
            call print_string_new;prints the message
            call print_nl_new;prints new line
            pop rax
            pop rbx
            pop rcx
            pop rdx
            pop rdi
            pop rsi
            ret
            
    
    


        
                        
display_menu:
    push rdi
    mov rdi, menu_str
    call print_string_new
    pop rdi
    ret
                                                
main:
    mov rbp, rsp; for correct debugging
    mov ebp, esp; for correct debugging
    mov rbp, rsp; for correct debugging
    ; We have these three lines for compatability only
    push rbp
    mov rbp, rsp
    sub rsp,32
    

    
    .menu_loop:
        call display_menu
        call read_int_new
        mov rdx, rax
        cmp rdx,1
        je .option_1
        cmp rdx, 2
        je .option_2
        cmp rdx,3
        je .option_3
        cmp rdx, 4
        je .option_4
        cmp rdx,5
        je .option_5
        cmp rdx, 6
        je .option_6
        cmp rdx, 7; Compares RDX to 7
        je .option_7 ;Exits if it is equal 7

        mov rdi, str_wrong_option
        call print_string_new
        jmp .menu_loop
        
    .option_1:
        call add_user
        jmp .menu_loop
    .option_2:
        call remove_user
        jmp .menu_loop
    .option_3:
        call add_pc
        jmp .menu_loop
    .option_4:
        call remove_pc
        jmp .menu_loop           
    .option_5:
        call display_users
        jmp .menu_loop
    .option_6:
        call display_pcs
        jmp .menu_loop    
    .option_7:
        call exit
            
        
exit:
    
    xor rax,rax ;return 0
    ;compatibility lines
    add rsp, 32
    pop rbp
    ;end of lines
    ret