; Coursework assembly program
%include "/home/malware/asm/joey_lib_io_v6_release.asm"
global main
section .data
    menu_str db 10, \
                        "Main Menu", 10, \
                        "1. Add user", 10, \
                        "2. Remove user", 10, \
                        "3. Add computer", 10, \
                        "4. Remove computer", 10, \
                        "5. List all users", 10, \
                        "6. List all computers", 10,\
                        "7. Exit", 10,\
                        "Please enter an option 1-7: ", 10,0
                         
    str_forename db "Enter user forename: ", 10, 0
    str_surname db "Enter user surname: ", 10, 0
    str_age db "Enter user age: ", 10, 0
    str_id db "Enter user id: ", 10, 0
    str_email db "Enter user email: ", 10, 0
    str_comp_name db "Enter computer name: ", 10, 0
    str_comp_ip db "Enter computer ID: ", 10, 0
    str_comp_os db "Enter computer OS: ", 10, 0
    str_user_id db "Enter the user id: ", 10, 0
    str_bad_id db "Wrong format of id", 10, 0
    str_bad_email db "Wrong format of email", 10,0
    str_DOP db "Enter date of purchase; ", 10 ,0
    
    str_option_num db "Option selected: ", 0
    str_wrong_option db "No such option, please try again! ", 10, 0
    str_exit db "You have exited the program!", 10, 0

    user_size equ 257 ;The total information size of an user
    max_users equ 100 ;Maximum users permited to add
    size_users_array equ user_size*max_users;
    current_users_num dq 0
    
    
section .bss
    users: resb size_users_array
    buff: resb 100;Buffer for the user input string
    email_buff: resb 100
    
   
section .text
format_email:
    push rax
    push rbx
    push rcx
    push rdi
    push rsi
    
    mov rbx, buff;rbx the pointer for the buffer
    .formating_loop:
        call read_string_new;stores input into rax
        mov rsi, rax; source to be copied into buffed
        mov rdi, rbx; destination to copy
        call copy_string; copies the string into the buffer
        mov al, BYTE[buff]
        cmp al, 0; if the string is empty, finish the process
        je .bad_format
        
        mov rax, QWORD[rbx]; moves the 8bit word into rax
        cmp al, '@';checks if the first syumbol is @ and displays error msg
        je .bad_format; jumps to the error msg
        
        .loop1:
            inc rbx; increments rbx to move to next char in the array
            mov rax, QWORD[rbx]; moves array 8bit char into rax
            cmp al ,'@'; compares if the 8 bit char is '@'
            jne .loop1
                        
        .loop2:
        inc rbx
        mov rax, QWORD[rbx]
        cmp al, 'h'
        jne .bad_format
        inc rbx
        mov rax, QWORD[rbx]
        cmp al, 'e'
        jne .bad_format
        inc rbx
        mov rax, QWORD[rbx]
        cmp al, 'l'
        jne .bad_format
        inc rbx
        mov rax, QWORD[rbx]
        cmp al, 'p'
        jne .bad_format
        inc rbx
        mov rax, QWORD[rbx]
        cmp al, 'd'
        jne .bad_format        
        inc rbx
        mov rax, QWORD[rbx]
        cmp al, 'e'
        jne .bad_format
        inc rbx
        mov rax, QWORD[rbx]
        cmp al, 's'
        jne .bad_format
        inc rbx
        mov rax, QWORD[rbx]
        cmp al, 'k'
        jne .bad_format
        inc rbx
        mov rax, QWORD[rbx]
        cmp al, '.'
        jne .bad_format
        inc rbx
        mov rax, QWORD[rbx]
        cmp al, 'c'
        jne .bad_format
        inc rbx
        mov rax, QWORD[rbx]
        cmp al, 'o'
        jne .bad_format
        inc rbx
        mov rax, QWORD[rbx]
        cmp al, '.'
        jne .bad_format
        inc rbx
        mov rax, QWORD[rbx]
        cmp al, 'u'
        jne .bad_format
        inc rbx
        mov rax, QWORD[rbx]
        cmp al, 'k'
        jne .bad_format
        inc rbx
        mov rax, QWORD[rbx]
        cmp al, 0
        jne .bad_format
        
        pop rax
        pop rbx
        pop rcx
        pop rdi
        pop rsi
        ret
                   
        
        .bad_format:
            mov rdi, str_bad_email
            call print_string_new
            call print_nl_new
            pop rax
            pop rbx
            pop rcx
            pop rdi
            pop rsi
            mov rsi, 1
            ret
        
        
        
        
        
    
format_ID:
    push rax
    push rbx
    push rcx
    push rdi
    push rsi
    
    mov rbx, buff; rbx used as pointer for the buffer
    .formating_loop:
        call read_string_new ;Stores input to rax
        mov rsi, rax; address of source to copy
        mov rdi, rbx; address of destionation to copy 
        call copy_string ;copies the string into the buffer
        mov al, BYTE[buff]; moves the first byte of the buff into the al
        cmp al,0; if the string is empty, finishes the process
        je .finish
        
        mov rax, QWORD[rbx]; moves the 8bit word into rax
        cmp al,'p';comparison for the first letter of the id
        jne .bad_id
        
        mov rcx, 7
        shr rax,8
        .num_loop: ;loops through the string
            
            cmp al, '0'
            jl .bad_id
            cmp al, '9'
            jg .bad_id
            shr rax,8; moves 8 bits on the right
            dec rcx; decrements the loop count
            cmp rcx,0;checks the counter 
            jne .num_loop;if is not 0 then loop again
            cmp al,0;check for null terminator
            jne .bad_id
            pop rax
            pop rbx
            pop rcx
            pop rdi
            pop rsi
            ret
            
            .bad_id:
                mov rdi, str_bad_id
                call print_string_new
                call print_nl_new
                
                pop rax
                pop rbx
                pop rcx
                pop rdi
                pop rsi
                mov rsi,1
                ret
            .finish:
                pop rax
                pop rbx
                pop rcx
                pop rdi
                pop rsi
                ret

add_user:
    push rbx
    push rcx
    push rdx
    push rdi
    push rsi
    
    mov rcx, users;setting the base address for the users array
    mov rax, QWORD[current_users_num] ; moving the current users number to rax
    mov rbx, user_size; moving 257 to rbx
    mul rbx ; Multiplies the current users number with the user size and calculates the offset of the next unused address
    add rcx, rax; adds the number of existing users to the users array to check what address is free next
    
    ;get forename
    mov rdi, str_forename ;moves the forename into rdi for printing out
    call print_string_new ;Prints the forename string
    call print_nl_new;prints new line
    call read_string_new;reads input and stores in rax
    mov rsi, rax;adds the address of the string to rsi
    mov rdi, rcx; add the memory address to the rdi
    call copy_string;copies the string from input to the user array
    
    ;get surname
    add rcx, 64 ;adds 64 to the rcx reserved by the forename string
    mov rdi, str_surname ;moves surname into rdi for printing
    call print_string_new; prints what inside rdi
    call print_nl_new;prints new line
    call read_string_new; reads input and stores into rax
    mov rsi, rax;Moves the user input into rsi
    mov rdi, rcx;Moves the reserved address for the surname into rdi for calling copy_string function
    call copy_string ;Copies the RSI content into the RDI address specified
    
    ;get age
    add rcx, 64; Moves 64 bits forward which is reserved for the surname193
    mov rdi, str_age;moves the age into rdi
    call print_string_new;prints the rdi contents
    call print_nl_new;prints new line
    call read_uint_new;takes input and stores into rax
    mov BYTE[rcx], al;copies only the last byte of rax[al] into rcx
    
    ;get id
    inc rcx ;increment by one because the age contains 1 byte only
    mov rdi, str_id; moves the message in rdi for printing out
    call print_string_new;prints out the message
    call print_nl_new;prints a new line
    call format_ID; calls the formating function
    cmp rsi,1;compares rsi to 1
    je .dont_add_id;compares if rsi is 1 then the id format is bad and is not going to be copied into the array
    ;adds the id into the array
    mov rsi, buff;moves the buffer which has the id string into the rsi, the source to be copied into the array
    mov rdi, rcx; points to the array address, destiantion for copying the array

    
    call copy_string; copies from rsi into rdi
    .dont_add_id:;jumps here for not adding the id to the array
        
    
    ;get email
    add rcx, 64; Moves 64bits forward reserved for the email
    mov rdi, str_email; Moves the message for email input into rdi
    call print_string_new;Prints out the email message string
    call print_nl_new; Prints out a new line
    call format_email
    cmp rsi,1
    je .dont_add_email
    mov rsi, buff
    mov rdi, rcx
    call copy_string
    .dont_add_email:
    
    
    inc QWORD[current_users_num];increases the existing number of users by 1
    pop rbx
    pop rcx
    pop rdx
    pop rdi
    pop rsi
    ret
 
display_users:
    push rbx
    push rcx
    push rdx
    push rdi
    push rsi
    
    lea rsi, [users] ;points to the array with users
    mov rcx, [current_users_num]; rcx used as a counter
    
    .start_loop:
    ;prints forename
    cmp rcx, 0;checks if the counter is 0
    je .end_loop
    mov rdi, rsi; put the pointer of the start of the users array to pass to the print out function
    call print_string_new
    call print_nl_new
    ;prints surname
    lea rdi, [rsi+64] ;moves 64 bit onto the array to print out the next 64 bytes whish is the surname
    call print_string_new
    call print_nl_new
    ;print age
    movzx rdi, BYTE[rsi+128]; extends the 8bytes reserved for the number with zeroes because the age in memory is 1byte and the rdi is 8bytes
    call print_uint_new
    call print_nl_new
    ;print user id
    lea rdi, [rsi+129];
    call print_string_new
    call print_nl_new
    ;print email
    lea rdi, [rsi+193]
    call print_string_new
    call print_nl_new
    call print_nl_new
    
    add rsi, user_size
    dec rcx; decrements rcx because it is one less user to be displayed
    
    jmp .start_loop
    
   .end_loop:
    pop rsi
    pop rdi
    pop rdx
    pop rbx
    pop rcx
    ret
                
    
    
    


        
                        
display_menu:
    push rdi
    mov rdi, menu_str
    call print_string_new
    pop rdi
    ret
                                                
main:
    mov rbp, rsp; for correct debugging
    ; We have these three lines for compatability only
    push rbp
    mov rbp, rsp
    sub rsp,32
    

    
    .menu_loop:
        call display_menu
        call read_int_new
        mov rdx, rax
        
        cmp rdx,1
        je .option_1
        cmp rdx,5
        je .option_5
        cmp rdx, 7; Compares RDX to 7
        je .option_7 ;Exits if it is equal 7
        mov rdi, str_wrong_option
        call print_string_new
        jmp .menu_loop
        
    .option_1:
        call add_user
        jmp .menu_loop
    
    .option_5:
        call display_users
        jmp .menu_loop
    
    .option_7:
        call exit
            
        
exit:
    
    xor rax,rax ;return 0
    ;compatibility lines
    add rsp, 32
    pop rbp
    ;end of lines
    ret